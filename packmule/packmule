#! /usr/local/bin/perl

# ###############################################
#
# packmule: make unattended loading environment
#
# Austin Shafer - 2018
#     ashaferian@gmail.com
#
# ###############################################

# This program is designed to fill an freebsd installation image
# with any packages supplied by the user. This results in an image
# which holds extra utilities installed by the user.

# The script mounts the .iso image under /mnt/bsd_iso and copies
# the file system to /tmp/bsd-iso-work. Packages and software is
# added to under /tmp/bsd-iso-work and written to a new .iso image

use strict;

use YAML;
use Cwd;
use Digest::SHA;

# global variables
my $mntdir = "/mnt/bsd_iso";
# directory holding copy of original iso
my $workroot = "/tmp/bsd-iso-work.$$";
# directory where custom software is installed
my $pkgroot = "/tmp/bsd-iso-pkgs.$$";
my $distdir = "$workroot/usr/freebsd-dist";
my $md_dev = 4;

my $pkg = "export ASSUME_ALWAYS_YES=yes; pkg -r $pkgroot install";
my $distname = "packmule-pkgs.txz";

# the packing list config file
my $plist = "packmule.yml";
# the name of the image to generate
my $isoname;

# debug option
# will do everything except generate the iso
my $DEBUG;
my $REMOVE;

# ################################################
# Function declarations
# ################################################

# mounts isoname at mntdir
sub mount_img () {
    print "Mounting $isoname at $mntdir\n";
    # NOTE:
    #       md node should be /dev/md${MD_DEV} for default
    # create vnode to mount under
    system("mdconfig -a -t vnode -f $isoname -u $md_dev");
    system("mount -t cd9660 /dev/md$md_dev $mntdir");
}

# ################################################
# unmounts ISONAME at MNTDIR
sub unmount_img () {
    print "Unmounting $isoname from $mntdir\n";

    system("umount $mntdir");
    # delete vnode (default is /dev/md${MD_DEV})
    system("mdconfig -d -u $md_dev");
}

# ################################################
# adds $distname to /usr/freebsd-dist/MANIFEST
sub manifest_add () {
    my $distdir = "/usr/freebsd-dist/";

    open(my $dist, "<", "$workroot/$distdir/$distname");
    binmode($dist);

    # generate sha256 checksum
    my $hash = Digest::SHA->new(256)->addfile($dist)->hexdigest;
    close $dist;

    # calculate number of archived packages
    my $nfiles = system("tar -t -f $workroot/$distdir/$distname | wc -l");
    # trim whitespace
    $nfiles =~ s/[^0-9]//g;

    # append packmule-pkgs.txz to $distdir/MANIFEST
    open(my $manifest, ">>", "$workroot/$distdir/MANIFEST");

    # from /usr/src/release/scripts/make-manifest.sh
    print $manifest "$distname\t$hash\t$nfiles\tpackmule\t\"Packmule custom pkgs\"\ton\n";

    close $manifest;
}

# ################################################
# writes WORKROOT to a new .iso file
sub write_new_img () {

    # change name from FreeBSD___.iso to FreeBSD___-packed.iso
    my $newisoname;
    if ($isoname =~ /.*\/([^\/]*).iso/) {
	$newisoname = "$1-packed.iso";
    }

    print "Writing new install package ./$newisoname\n";

    my $target;
    # 4th group of something followed by '-'
    if ($newisoname =~ /(([^-]*)-){4}/) {
	$target = $2;
    }

    # construct volume label from isoname
    my $volume_label;
    if ($newisoname =~ /-(.*)-.*/) {
	$volume_label = $1;
	# change all dots and slashes to underscores
	$volume_label =~ s/(\.|-)/_/g;
    }

    print "VOLUME_LABEL = $volume_label\n";

    # run machine dependent script to build install .iso
    system("sh /usr/src/release/$target/mkisoimages.sh -b $volume_label "
	   . "$newisoname $workroot");
}

# ################################################
# A bit of a hack, but copying the password db is
# used because symlinks are not allowed. The passwd
# program will just create a new db overwriting the
# symlinks...

# ################################################
# copy password db so that
# installed packages can create groups
sub link_passwd () {
    system("mkdir -p $pkgroot/etc/");

    system("cp $workroot/etc/passwd $pkgroot/etc/passwd");
    system("cp $workroot/etc/master.passwd $pkgroot/etc/master.passwd");
    system("cp $workroot/etc/pwd.db $pkgroot/etc/pwd.db");
    system("cp $workroot/etc/spwd.db $pkgroot/etc/spwd.db");
    system("cp $workroot/etc/group $pkgroot/etc/group");
    system("cp $workroot/etc/shells $pkgroot/etc/shells");
}

# ################################################
# remove password db links so that
# installed packages can create groups
sub unlink_passwd () {
    system("cp $pkgroot/etc/passwd $workroot/etc/passwd");
    system("cp $pkgroot/etc/master.passwd $workroot/etc/master.passwd");
    system("cp $pkgroot/etc/pwd.db $workroot/etc/pwd.db");
    system("cp $pkgroot/etc/spwd.db $workroot/etc/spwd.db");
    system("cp $pkgroot/etc/group $workroot/etc/group");
    system("cp $pkgroot/etc/shells $workroot/etc/shells");

    system("rm $pkgroot/etc/passwd");
    system("rm $pkgroot/etc/master.passwd");
    system("rm $pkgroot/etc/pwd.db");
    system("rm $pkgroot/etc/spwd.db");
    system("rm $pkgroot/etc/group");
    system("rm $pkgroot/etc/shells");
}

# ################################################
# removes directory listings
sub remove_dirs() {
    system("rm -rf $workroot");
    system("rm -rf $pkgroot");
}

# ################################################
# BEGIN MAIN
# ################################################


# #######################
# process command line arguments
while (@ARGV != 0) {
    my $arg = shift;

    if ($arg eq "-y") {
	$plist = shift;

    } elsif ($arg eq "-D") {
	$DEBUG = 1;

    } elsif ($arg eq "--no-pkg-scripts" or $arg eq "-I") {
	# do not run pre-install / post-install scripts for
	# compatibility sake. Some scripts fail due to the
	# '-r' option on pkg
	$pkg .= " -I ";

    } elsif ($arg eq "-R") {
	$REMOVE = 1;
	
    } elsif (!defined($isoname)) {
	$isoname = $arg;

    } else {
	print "Skipping unrecognized argument $arg\n";
    }
}

# #######################
# isoname must be set
if (!defined($isoname)) {
    print "Usage: packmule [-y /path/to/config.yml] isoname\n";
    print "       (Default config is ./packmule.yaml)\n";
    exit(1);
} elsif (!defined($REMOVE)) {
    print "packmule: Removing mounts.\n";
    remove_dirs();
    unmount_img();
    exit(0);
} 

my $config = YAML::LoadFile($plist);

# create directories if needed
remove_dirs;
system("mkdir -p $mntdir");
system("mkdir -p $workroot");
system("mkdir -p $pkgroot");

# mount the .iso
mount_img;

# copy image to r/w direcotry $workroot
print "--------------------------------------------------\n";
print "Copying filesystem from $mntdir to $workroot...\n";
print "--------------------------------------------------\n";
system("cp -R $mntdir/* $workroot/");

# use pkg to fill new image tree
print "--------------------------------------------------\n";
print "Installing packages in $pkgroot...\n";
print "--------------------------------------------------\n";

# setup

# create temporary password and group files
link_passwd();

# install packages in directory to tar
# dereference array PKGS references
my @packages = @{$config->{PKGS}};
for my $p (@packages) {
    print "$pkg install $p\n";
    system("$pkg $p\n");
}

# dereference hash CUSTOM references
my %customs = %{$config->{CUSTOM}};
for my $c (keys %customs) {
    my $val = %customs{$c};

    # make the directory to install to
    my $valdir = system("dirname $pkgroot/$val");
    system("mkdir -p $valdir");

    print "cp $c $pkgroot/$val\n";
    system("cp $c $pkgroot/$val\n");
}

my $installerconfig = $config->{INSTALLERCONFIG};
if ($installerconfig) {
    system("cp $installerconfig $workroot/etc/");
}

# clear pkg files for efficiency
system("rm -rf $pkgroot/var/cache/pkg");
system("rm -rf $pkgroot/var/db/pkg");

# check if DEBUG is defined
if ($DEBUG) {
    # stop so we can check out the mounted files
    print "--------------------------------------------------\n";
    print "DEBUG flag set. Not generating iso image.\n";
    print "--------------------------------------------------\n";
    exit(0);
}

# remove password db links
unlink_passwd();

# pack up the custom stuff as a distribution tar
print "--------------------------------------------------\n";
print "Creating distribution file $distdir/$distname...\n";
print "--------------------------------------------------\n";

my $startdir = getcwd;

chdir "$pkgroot" || die "cannot change to $pkgroot\n";
system("tar -cvJpf $distdir/$distname ./");
chdir "$startdir" || die "cannot change back to start dir\n";

# add $distname to MANIFEST
manifest_add;

# pretty self explanatory by the function name
print "--------------------------------------------------\n";
write_new_img;
print "--------------------------------------------------\n";

# unmount and free vnode
print "--------------------------------------------------\n";
print "Deleting $workroot...\n";
print "--------------------------------------------------\n";
remove_dirs;
unmount_img;

# bye
exit(0);
