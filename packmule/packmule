#! /usr/local/bin/perl

# ###############################################
#
# mule: make unattended loading environment
#
# Austin Shafer - 2018
#     ashaferian@gmail.com
#
# ###############################################

# This program is designed to fill an freebsd installation image 
# with any packages supplied by the user. This results in an image
# which holds extra utilities installed by the user.

# The script mounts the .iso image under /mnt/bsd_iso and copies
# the file system to /tmp/bsd_iso_work. Packages and software is
# added to under /tmp/bsd_iso_work and written to a new .iso image

use strict;

use YAML;
use Cwd;
use Digest::SHA;

# global variables
my $mntdir = "/mnt/bsd_iso";
my $workroot = "/tmp/bsd_iso_work";
my $pkgroot = "/tmp/bsd_iso_pkgs";
my $distdir = "$workroot/usr/freebsd-dist";
my $md_dev = 4;

my $pkg = "export ASSUME_ALWAYS_YES=yes; pkg -r $pkgroot";
my $distname = "packmule-pkgs.txz";

# the packing list config file
my $plist = "packmule.yml";
# the name of the image to generate
my $isoname = "null";

# ################################################
# Function declarations
# ################################################

# mounts isoname at mntdir
sub mount_img () {
    print "Mounting $isoname at $mntdir\n";
    # NOTE:
    #       md node should be /dev/md${MD_DEV} for default
    # create vnode to mount under
    `mdconfig -a -t vnode -f $isoname -u $md_dev`;
    `mount -t cd9660 /dev/md$md_dev $mntdir`;
}

# ################################################
# unmounts ISONAME at MNTDIR
sub unmount_img () {
    print "Unmounting $isoname from $mntdir\n";

    `umount $mntdir`;
    # delete vnode (default is /dev/md${MD_DEV})
    `mdconfig -d -u $md_dev`;
}

# ################################################
# adds $distname to /usr/freebsd-dist/MANIFEST
sub manifest_add () {
    my $distdir = "/usr/freebsd-dist/";
    
    open(my $dist, "<", "$workroot/$distdir/$distname");
    binmode($dist);

    # generate sha256 checksum
    my $hash = Digest::SHA->new(256)->addfile($dist)->hexdigest;
    close $dist;

    # calculate number of archived packages
    my $nfiles = `tar -t -f $workroot/$distdir/$distname | wc -l`;
    # trim whitespace
    $nfiles =~ s/[^0-9]//g;

    # append packmule-pkgs.txz to $distdir/MANIFEST
    open(my $manifest, ">>", "$workroot/$distdir/MANIFEST");

    # from /usr/src/release/scripts/make-manifest.sh
    print $manifest "$distname\t$hash\t$nfiles\tpackmule\t\"Packmule custom pkgs\"\ton\n";

    close $manifest;
}

# ################################################
# writes WORKROOT to a new .iso file
sub write_new_img () {

    # change name from FreeBSD___.iso to FreeBSD___-packed.iso
    my $newisoname;
    if ($isoname =~ /.*\/([^\/]*).iso/) {
	$newisoname = "$1-packed.iso";
    }

    print "Writing new install package ./$newisoname\n";

    my $target;
    # 4th group of something followed by '-'
    if ($newisoname =~ /(([^-]*)-){4}/) {
	$target = $2;
    }
    
    # construct volume label from isoname
    my $volume_label;
    if ($newisoname =~ /-(.*)-.*/) {
	$volume_label = $1;
	# change all dots and slashes to underscores
	$volume_label =~ s/(\.|-)/_/g;
    }

    print "VOLUME_LABEL = $volume_label\n";

    # run machine dependent script to build install .iso
    `sh /usr/src/release/$target/mkisoimages.sh -b $volume_label $newisoname $workroot`;
}

# ################################################
# removes directory listings
sub remove_dirs() {
    `rm -rf $workroot`;
    `rm -rf $pkgroot`;
}

# ################################################ 
# BEGIN MAIN
# ################################################ 

# process command line arguments
while (@ARGV != 0) {
    my $arg = shift;

    if ($arg eq "-y") {
	$plist = shift; 
    } elsif ($isoname eq "null") {
	$isoname = $arg;
    } else {
	print "Skipping unrecognized argument $arg\n";
    }
}

# isoname must be set
if ($isoname eq "null") {
    print "Usage: packmule [-y /path/to/config.yml] isoname\n";
    print "       (Default config is ./packmule.yaml)\n";
    exit(1);
}

my $config = YAML::LoadFile($plist);

# create directories if needed
remove_dirs;
`mkdir -p $mntdir`;
`mkdir -p $workroot`;
`mkdir -p $pkgroot`;

# mount the .iso
mount_img;

# copy image to r/w direcotry $workroot
print "--------------------------------------------------\n";
print "Copying filesystem from $mntdir to $workroot...\n";
print "--------------------------------------------------\n";
`cp -R $mntdir/* $workroot/`;

# use pkg to fill new image tree
print "--------------------------------------------------\n";
print "Installing packages in $workroot...\n";
print "--------------------------------------------------\n";

# install packages in directory to tar

# dereference array PKGS references
my @packages = @{$config->{PKGS}};
for my $p (@packages) {
    print "$pkg install $p\n";
    `$pkg install $p\n`;
}

#dereference hash CUSTOM references
my %customs = %{$config->{CUSTOM}};
for my $c (keys %customs){
    my $val = %customs{$c};
    print "cp $c $pkgroot/$val\n";
    `cp $c $pkgroot/$val\n`;
}

# pack up the custom stuff as a distribution tar
print "--------------------------------------------------\n";
print "Creating distribution file $distdir/$distname...\n";
print "--------------------------------------------------\n";

my $startdir = getcwd;

chdir "$pkgroot" || die "cannot change to $pkgroot\n";
`tar -cvJpf $distdir/$distname ./`;
chdir "$startdir" || die "cannot change back to start dir\n";

# add $distname to MANIFEST
manifest_add;

# pretty self explanatory by the function name
print "--------------------------------------------------\n";
write_new_img;
print "--------------------------------------------------\n";

# unmount and free vnode
print "--------------------------------------------------\n";
print "Deleting $workroot...\n";
print "--------------------------------------------------\n";
remove_dirs;
unmount_img;
